(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{228:function(e,t,s){"use strict";s.r(t);var r=s(0),a=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"kubernetes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes","aria-hidden":"true"}},[this._v("#")]),this._v(" Kubernetes")]),this._v(" "),t("h3",{attrs:{id:"kubernetes-api-style"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-api-style","aria-hidden":"true"}},[this._v("#")]),this._v(" Kubernetes API Style")]),this._v(" "),t("p",[this._v("Kubernetes API reflects a simple idea; it reconciles between the desired state of an extensible set of resources and the actual state.\nIt provides a RESTful API for resources but will wait for a scheduler to schedule the actual resources when the workload is ready.\nThe end-user of Kubernetes API does not necessary to know how the resources are allocated but simply to know the resources will be allocated eventually.\nThis creates a lot of values and changes the way people design the APIs.\nWill the Kubernetes API itself can be used to support any other resources?")])])}],!1,null,null,null);t.default=a.exports}}]);